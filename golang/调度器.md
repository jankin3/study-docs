# 调度器

Go的一个重要的特点就是`并发编程`，这源于golang在语言层面就支持的多协程。



### 操作系统的协程，线程，进程关系

进程是系统分配和调度资源的基本单位，线程是cpu进行分配和调度的基本单位。线程相比进程更加轻量化，同一个进程下的多个线程可以共享一块内存，可以基于共享内存进行通信。

虽然线程比较轻量，但是在调度时也有比较大的额外开销。每个线程会都占用 1M 以上的内存空间，在切换线程时不止会消耗较多的内存，恢复寄存器中的内容还需要向操作系统申请或者销毁资源，每一次线程上下文的切换都需要消耗 ~1us 左右的时间，但是 Go 调度器对 Goroutine 的上下文切换约为 ~0.2us，减少了 80% 的额外开销

Go 语言的调度器通过使用与 CPU 数量相等的线程减少线程频繁切换的内存开销，同时在每一个线程上执行额外开销更低的 Goroutine 来降低操作系统和硬件的负载。



### GMP模型

![golang-scheduler](https://img.draveness.me/2020-02-05-15808864354595-golang-scheduler.png)

1. G — 表示 Goroutine，它是一个待执行的任务；
2. M — 表示操作系统的线程，它由操作系统的调度器调度和管理；
3. P — 表示处理器，它可以被看做运行在线程上的本地调度器；



#### 总结一下，协程可以支持高并发的优势？

1. 占用的内存少，每个只需要几kb
2. 完全处于用户态，方便调度
3. 一个线程M可以支持多个协程处理，充分利用cpu