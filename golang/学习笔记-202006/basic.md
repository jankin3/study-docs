#　Golang基础

###　语言特点

1. 编译性的静态类型的语言
2. 并发支持

理解, c/java执行速度快,但是开发速度较慢. python/php开发快速但是效率慢. 结合前辈的特点出现了golang，也被称为21世纪的c语言。再者就是，golang天生充分利用多核cpu的特性,并发的支持上非常棒.



### 变量

1. 标识名 

   + 字母或者下划线开始, 注意,非数字开头
   + 包内大写字母开头表示包外部可以访问, 小写则不可以
   + 驼峰命名

2. 声明

   + 标准声明

     ```go
     var name type value
     // type 可以省略,根据value判断
     // value可以省略,默认值,即各个数据类型的0值 
     ```

   + 短声明

     ```go
      name := value
      // 比较简短快捷,使用较多
     ```

   + 匿名声明 new(T), 使用较少

3. 生命周期

   + 包级别,和整个程序运行周期一致
   + 函数级别, 创建开始,不在引用结束

4. 赋值, 

   + 允许元组复制 比如x,y = y, x(类似python)
   + 允许元组复制 比如x,y = y, x(类似python)

### 类型

```go
type typeName 底层类型
// eg: type Celsius float64    // 摄氏温度
```

定义：创建一种新的数据类型，和现有底层的数据结构一致。用来分隔不同概念的类型，这样即使它们底层类型相同也是不兼容的

作用：

+ 分隔不同概念的类型, 避免表达式中的混用，会报错

### 包

省略

### 作用域

定义：代码中可以有效使用该名字的范围

区别声明周期：

+ 生命周期是`运行时`的概念
+ 作用域是`编译期`的概念

使用：从内部依次向外部寻找

注意：go不允许声明了之后不使用



## 数据类型

### 整形

有符号int， 无符号uint

种类：int8， int16，int32， int64,分别表示n位长度bit来存储， 如果是int则表示与特定的机器cpu相关

### 浮点数

两种长度 float32， float64

### 复数

两种长度 complex64, complex128

### 布尔型

true或者false

### 字符串

定义：不可改变的字节序列， 文本字符串通常解释为采用utf-8存储的unicode序列

使用：len返回字节数目，注意是字节数目，而不是字符。 同样采用索引取值s[i]也是返回第i个字节的值。在字符串出现多字节的字符的时候尤其注意。

### 常量

定义：值不可修改的数据，在编译器执行

使用:

 1. const关键字定义

 2. 同时定义多个

    ```go
    const (
      a = 0
      b = 1
    )
    ```



### 数组

定义：固定长度的数据序列，可以通过索引下标来访问

缺点：长度固定，不能灵活增加和减少

使用：

```go
var a [3]int
var a [3]int = [3]int{1, 4, 5} // 指定长度
a := [...]int{1,3,5} // 省略长度
```



### 切片slice

定义：变长的序列，序列中每个元素都是相同的类型。

使用：

```
a := []int{1,4,6} // 不指定长度则为切片
```

特点：

1. 从内容上，包含三个元素，指针，长度，容量
2. 轻量级的数据结构，提供了访问数组子序列的功能
3. 共享底层的数组结构，其实就是引用，可以传入函数进行引用传递
4. slice之间不能做==比较，因为是slice的元素是间接引用的，具体的意思待探究



### Map

定义：哈希表，也就是python中的字典

特点：

1. 键必须是一个类型，值必须是一个类型

2. 获取不存在的键会返回值类型的0值,所以判断一个键是否存在

   ```go
   v,ok = m[k] //如果不存在则返回的第二个值ok为false
   ```

3. 顺序不一定，遍历时返回的键值对是随机的

使用：

```go
delete(m, "key") //删除
```



### 指针

to-do



### json

定义：json是一种用于发送和接受结构化信息的标准协议， 类似xml等

特点：

1. tag，可以简单处理及转换字段
2. 使用结构体可以选择性接受部分字段

使用：

1. 数据结构与json的转换

```go
// 1. 转换成json, Marshal()
data, err = json.Marshal(movies) //或者Marshalindent(), 可读性更好
fmt.Printf("%s", data)
// 这里有一点疑惑，打印typeof(data), 结果是[]uint8 ???

// 2. json转换成对象, Unmarshal()
var titles []struct { Title string}
  if err := json.Unmarshal(data, &titles); err != nil{
    log.Fatalf("error, %s", err)
}
fmt.Println(titles)
```





## 函数

定义：

```go
func funcName(arg-list) (result-list) {
  // do something 
} 
```

特点：

1. 支持递归

2. bare return, 如果一个函数将所有的返回值都显示的变量名，那么该函数的return语句可以省略操作数

3. 错误， 在Go中，函数运行失败时会返回错误信息，这些错误信息被认为是一种预期的值而非异常（exception），这使得Go有别于那些将函数运行失败看作是异常的语言

4. 函数值，函数被看作第一类值（first-class values）：函数像其他值一样，拥有类型，可以被赋值给其他变量，传递给函数，从函数返回

5. 支持闭包，匿名函数，类似php

6. 可变参数, 在声明可变参数函数时，需要在参数列表的最后一个参数类型之前加上省略符号“...”，这表示该函数会接收任意数量的该类型参数。

   ```go
   func funcName(args...int)
   ```

7. defer 关键字

   定义：当defer语句被执行时，跟在defer后面的函数会被延迟执行。直到包含该defer语句的函数执行完毕时，defer后的函数才会被执行，不论包含defer语句的函数是通过return正常结束，还是由于panic导致的异常结束。你可以在一个函数中执行多条defer语句，它们的执行顺序与声明顺序相反

   作用：defer语句经常被用于处理成对的操作，如打开、关闭、连接、断开连接、加锁、释放锁

   ```go
   defer resp.Body.Close()
   ```

8. panic异常